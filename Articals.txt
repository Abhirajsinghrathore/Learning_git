Please send some articals to this also:-

<---------------------First Article---------------------------->
Marcus Geduld
Marcus Geduld, 30 years of coding.
Updated Aug 11, 2015 · Upvoted by Martin Krämer, MSc in CS '07. Worked since then as SE with a 2-3 year break doing ML research.
Originally Answered: What is Git used for? What does it do exactly?
Git allows a team of people to work together, all using the same files. And it helps the team cope with the confusion that tends to happen when multiple people are editing the same files.

There are many ways it can be set up and configured, but at my job, here's how we use it: when a new employee starts, he downloads all the files from Github, which is an online server we're all connected to.

So he has his local version of the files, I have my local version, our boss has his local version, etc.

When I make a change to some files, I go through the following process in the Terminal. (There are GUI clients for Git, but I prefer working on the command line.)

 > git pull

That pulls the latest changes down from github. If there are conflicts between those and my local ones, it tells me what they are, file-by-file, line-by-line, and I now have a chance to reconcile those differences.

After editing the files or creating new ones, I run this command:

 > git add .

Which adds all of my local changes to git, so that git knows about them. The dot after add specifically means to add all the changes I've made, e.g. new files I've added to my local folder or changes I've made to existing files. If I want, I can add only specific files, e.g.

 > git add myNewFile.js

I now write a comment about the adds I just made.

 > git commit -m "Fixed a major bug which stopped reports from printing."

Finally, I upload my changes to the server.

 > git push

Now, when my colleagues do a ...

 > git pull

... they will get my changes, and they will be notified if any of them conflict with their local versions.

There are all kinds of cool, useful commands for rolling back changes to a particular time or state. But probably the most useful thing about Git is branching. Let's say my team is working on code for an Asteroids game, and I get the idea for making spinning asteroids. This will involve making some major changes to the existing asteroids code, and I'm a little scared to do that. No worries, I can just make a branch.

First of all, I'll check which branches exist:

     > git branch
    master*



So there's currently only one branch on my local machine, called master. The star by it means that's the branch I'm currently working in. I'll go ahead and create a new one:

 > git branch spinningAsteroids

That creates a copy of all the files in master. I'll now move into that branch.

     > git checkout spinningAsteroids
    > git branch
    master
    spinningAsteroids*



I now spend a couple of hours in spinningAsteroids, doing whatever coding I need to do, not worrying about messing things up, because I'm in a branch. Meanwhile, I get a tech support call. They've found a critical bug and I need to fix it asap. No worries...

 > git checkout master

... fix bug ...

     > git pull
    > git add .
    > git commit -m "Fixed critical bug with high scores."
    > git push



Now I can resume my work with spinningAsteroids.

     > git checkout spinningAsteroids
    > git branch
    master
    spinningAsteroids*



... work, work, work ...

Okay, I'm now happy with my spinning asteroids, and I want to merge that new code into the main code base, so...

     > git checkout master
    > git branch
    master*
    spinningAsteroids



 > git merge spinningAsteroids

Now the code from my branch is merged into the main code-base. I can now upload it.

     > git pull
    > git add .
    > git commit -m "added new cool feature! Spinning asteroids!!!"
    > git push



There are many ways to use Git. This is just one of them

<-------------------------END------------------------->






<--------ashwani second article------->
What is GitHub?

GitHub is a code hosting platform for version control and collaboration. It lets you and others work together on projects from anywhere.

This tutorial teaches you GitHub essentials like repositories, branches, commits, and Pull Requests. You’ll create your own Hello World repository and learn GitHub’s Pull Request workflow, a popular way to create and review code.
No coding necessary

To complete this tutorial, you need a GitHub.com account and Internet access. You don’t need to know how to code, use the command line, or install Git (the version control software GitHub is built on).

    Tip: Open this guide in a separate browser window (or tab) so you can see it while you complete the steps in the tutorial.
<<---------------end ----------------->>






<------------------------------Google Guava Library for Java--------------------------->

The Guava project contains several of Google's core libraries that we rely on in our Java-based projects: collections, caching, primitives support, concurrency libraries, common annotations, string processing, I/O, and so forth. Each of these tools really do get used every day by Googlers, in production services.

But trawling through Javadoc isn't always the most effective way to learn how to make best use of a library. Here, we try to provide readable and pleasant explanations of some of the most popular and most powerful features of Guava.

This wiki is a work in progress, and parts of it may still be under construction.

    Basic utilities: Make using the Java language more pleasant.
        Using and avoiding null: null can be ambiguous, can cause confusing errors, and is sometimes just plain unpleasant. Many Guava utilities reject and fail fast on nulls, rather than accepting them blindly.
        Preconditions: Test preconditions for your methods more easily.
        Common object methods: Simplify implementing Object methods, like hashCode() and toString().
        Ordering: Guava's powerful "fluent Comparator" class.
        Throwables: Simplify propagating and examining exceptions and errors.
    Collections: Guava's extensions to the JDK collections ecosystem. These are some of the most mature and popular parts of Guava.
        Immutable collections, for defensive programming, constant collections, and improved efficiency.
        New collection types, for use cases that the JDK collections don't address as well as they could: multisets, multimaps, tables, bidirectional maps, and more.
        Powerful collection utilities, for common operations not provided in java.util.Collections.
        Extension utilities: writing a Collection decorator? Implementing Iterator? We can make that easier.
    Caches: Local caching, done right, and supporting a wide variety of expiration behaviors.
    Functional idioms: Used sparingly, Guava's functional idioms can significantly simplify code.
    Concurrency: Powerful, simple abstractions to make it easier to write correct concurrent code.
        ListenableFuture: Futures, with callbacks when they are finished.
        Service: Things that start up and shut down, taking care of the difficult state logic for you.
    Strings: A few extremely useful string utilities: splitting, joining, padding, and more.
    Primitives: operations on primitive types, like int and char, not provided by the JDK, including unsigned variants for some types.
    Ranges: Guava's powerful API for dealing with ranges on Comparable types, both continuous and discrete.
    I/O: Simplified I/O operations, especially on whole I/O streams and files, for Java 5 and 6.
    Hashing: Tools for more sophisticated hashes than what's provided by Object.hashCode(), including Bloom filters.
    EventBus: Publish-subscribe-style communication between components without requiring the components to explicitly register with one another.
    Math: Optimized, thoroughly tested math utilities not provided by the JDK.
    Reflection: Guava utilities for Java's reflective capabilities.
    Tips: Getting your application working the way you want it to with Guava.
        Philosophy: what Guava is and isn't, and our goals.
        Using Guava in your build, with build systems including Maven, Gradle, and more.
        Using ProGuard to avoid bundling parts of Guava you don't use with your JAR.
        Apache Commons equivalents, helping you translate code from using Apache Commons Collections.
        Compatibility, details between Guava versions.
        Idea Graveyard, feature requests that have been conclusively rejected.
        Friends, open-source projects we like and admire.
        HowToContribute, how to contribute to Guava.

<-------------------------------------End------------------------------------->

<------------------------------------Fourth Artical--------------------------->
Django (/ˈdʒæŋɡoʊ/ JANG-goh)[4] is a free and open-source web framework, written in Python, which follows the model-view-template
(MVT) architectural pattern.[5][6] It is maintained by the Django Software Foundation (DSF), an independent organization established
as a 501(c)(3) non-profit.

Django's primary goal is to ease the creation of complex, database-driven websites. Django emphasizes reusability and "pluggability"
of components, rapid development, and the principle of don't repeat yourself. Python is used throughout, even for settings files
and data models. Django also provides an optional administrative create, read, update and delete interface that is generated
dynamically through introspection and configured via admin models.

Some well-known sites that use Django include the Public Broadcasting Service,[7] Pinterest,[8] Instagram,[9] Mozilla,[10]
The Washington Times,[11] Disqus,[12] Bitbucket,[13] and Nextdoor.[14]
<---------------------------------------End---------------------------------->


<----------------------------------JSF FrameWork------------------------------>
JavaServer Faces (JSF) is a Java specification for building component-based user interfaces for web applications.[1] It was formalized as a standard through the Java Community Process and is part of the Java Platform, Enterprise Edition.

JSF 2 uses Facelets as its default templating system. Other view technologies such as XUL or plain Java[2] can also be employed. In contrast, JSF 1.x uses JavaServer Pages (JSP) as its default templating system.

													HOW IT WORKS?

Based on a component-driven UI design-model, JavaServer Faces uses XML files called view templates or Facelets views. The FacesServlet processes requests, loads the appropriate view template, builds a component tree, processes events, and renders the response (typically in the HTML language) to the client. The state of UI components and other objects of scope interest is saved at the end of each request in a process called stateSaving (note: transient true), and restored upon next creation of that view. Either the client or the server side can save objects and states.
<------------------------------------End-------------------------------------->

--------------------------------------------------------------------------------
TEST EDIT - 27/9/2016
Aurio
---------------------------------------End---------------------------------------

--------------------------------------Useless Rant--------------------------------
$ git remote -v

$ git pull upstream master

	OR

$ git fetch upstream 
$ git merge master upstream/master   // Alternative : $ git rebase upstream/master


-Akshat
---------------------------------------End-----------------------------------------

<----------------------------------------GET STARTED WITH GIT---------------------------------------------------------->

This article covers why version control is important, how to install the Git version control system, and how to get started with your first repository. Once you start using Git, you’ll want to throw everything into it, from full-blown apps to blog post drafts, because it’s so easy and versatile.
Why do I need version control?

While it may be obvious that large development teams should have sophisticated code-management systems to track releases and bugs, and to avoid stepping on each others’ toes, it might not be immediately clear why individuals would need version control—especially designers or writers.

But take a look at a site like Wikipedia, which is built around collaborative user content editing. One of Wikipedia’s best features is the ability to compare two versions of an article. When you do this, you’re actually performing a diff, one of version control’s central concepts. And when you decide to add or change content, you’re committing a revision. With Git, you can add this Wikipedia-like functionality to any folder, and it will automatically start looking for changes in files contained within it, even if they’re not text files. In Git parlance, that folder becomes your repository.

With Git, though, you can do much more. Branching and merging are powerful tools for integrating changes without compromising more stable work that might, for example, be running on a production website. Remotes are copies of whole repositories that are transferred over a network, and are really helpful for collaborating on projects with people both in your office and over the internet.
No more circus file naming

At the very least, Git can save you the tedium of file name versioning (e.g., avoiding untitled-1-new-v2.html). At best, it can help you work faster by saving your changes, managing different ideas and features in your project, and even serving as a backup strategy. Because Git unobtrusively operates on whole folders, it won’t interfere in your day-to-day work until you explicitly ask it to save a project snapshot at any given time. And permanently removing Git from a folder is just one command away.

Git changes the way you work by making risk cheaper. Unlike haphazard “multiple undo” and “autosave” features common in many editors and graphics packages, Git expects you to control how and when to commit changes to a project, and, in doing so, allows your project to evolve from any one of these changes. Plus, it does this without having any extra administrative debris around versioning (think labels, markers, and extra files) in your project. Any of these changes can be merged automatically, so you never have to repeat yourself or try to figure out how to redo something you overwrote. For this reason, Joel Spolsky called Git a “change control system” instead of a version control system because rather than presenting a project linearly (the “undo” mentality), Git just sees a handful of commits always ready to be reshuffled or squashed together:

    When you manage changes instead of managing versions, merging works better, and therefore, you can branch any time your organizational goals require it, because merging back will be a piece of cake.

In the beginning was the command line

Git is unlike most modern OS-native applications in that there is (mostly) no graphical user interface; it is totally controlled via the command line. This may seem daunting at first, but the few common commands will quickly become second nature. If you’re new to the command line, I highly recommend Dan Benjamin’s screencast, Meet the Command Line, as a quick crash course.

For the more visually inclined, there are a few graphical tools to browse and manipulate Git repositories. Git comes with two programs, one called gitk for browsing your project history, and another called git-gui for adding files and creating commits. With these two mini apps, you won’t need to use the command line interface much; but you may be surprised to find that it is actually quicker to use the Git commands than git-gui or gitk, especially if you upload your project to GitHub, which has an excellent source browser. Mac OS X users should check out GitX, a prettier version of gitk/git-gui to visualize and edit repositories. The official wiki has a comprehensive list of graphical interfaces for Git.
Housekeeping, before we get started

When referring to the terminal, I’ll use prompt> to represent the command prompt and what to type after it. Everything under the prompt> line is what will be displayed after you hit return. The Unix shell is terse, meaning, it won’t tell you if something went right—only if something goes wrong. Git is pretty good about telling you what it’s doing, but don’t be alarmed if not every command gives you a response.
<-------------------------------------------------END-------------------------------------------------------------------->